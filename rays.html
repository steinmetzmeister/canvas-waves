<style>
body {
  padding: 0px;
  margin: 0px;
}
</style>

<div id="container"></div>
<audio id="audio" style="display: none;">
    <source src="http://xstream1.somafm.com:8062/;" type="audio/mpeg">
    Your browser does not support the audio element.
</audio>

<script type="text/javascript" src="./js/jquery-1.11.1.min.js"></script>
<script type="text/javascript" src="./js/three.min.js"></script>
<script type="text/javascript" src="./js/util.js"></script>
<script type="text/javascript" src="./js/perlin.js"></script>
<script type="text/javascript" src="./js/visualizer.js"></script>
<script type="text/javascript" src="./js/controller.js"></script>

<script type="text/javascript">
var Main = {
  angle: 0,
  angularVelocity: 0,

  init: function(container) {
    this.renderer = new THREE.WebGLRenderer();
    this.renderer.setSize(window.innerWidth, window.innerHeight);

    document.getElementById(container).appendChild(this.renderer.domElement);

    this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
    this.scene = new THREE.Scene();

    Main.camera.position.x = Math.sin(90) * 128;
    Main.camera.position.z = Math.cos(90) * 128;

    this.camera.position.y = -64;

    this.rPrevDist = 0;
    this.bPrevDist = 0;
  },

  animate: function() {
    requestAnimationFrame(Main.animate);

    Main.angle += 0.01;

    Main.update();
    Main.camera.position.x = Math.sin(Main.angle * 0.25) * 128;
    Main.camera.position.z = Math.cos(Main.angle * 0.25) * 128;

    // greenBox.position.y = Math.sin(Main.angle) * 25;

    Main.camera.lookAt(new THREE.Vector3(0, -64, 0));
    Main.render();
  },

  render: function() {
    this.renderer.render(this.scene, this.camera);
  },

  update: function() {

    greenBox.position.y -= 2;

    yellowBox.position.z = (Math.sin(this.angle * 4) * 25) - 50;
    yellowBox.position.y = (Math.sin(this.angle * 4) * 50) - 50;

    //

    var clone = redBox.position.clone();
    greenBox.localToWorld(clone);

    var raycaster = new THREE.Raycaster(clone, new THREE.Vector3(0, -1, 0).normalize(), 1, 12.5);
    var intersect = raycaster.intersectObjects([yellowBox, yellowBoxB]);

    //

    var cloneB = blueBox.position.clone();
    greenBox.localToWorld(cloneB);

    var raycasterB = new THREE.Raycaster(cloneB, new THREE.Vector3(0, -1, 0).normalize(), 1, 12.5);
    var intersectB = raycasterB.intersectObjects([yellowBox, yellowBoxB]);

    var redPoint = redBox.position.clone();
    greenBox.localToWorld(redPoint);

    //

    if (intersect.length > 0 && intersectB.length > 0)
    {
      Main.angularVelocity = 0;
    }
    else
    {
      if (intersect.length == 0 & intersectB.length != 0)
        Main.angularVelocity -= 0.1;

      if (intersect.length != 0 & intersectB.length == 0)
        Main.angularVelocity += 0.1;
    }

    greenBox.rotation.x += Main.angularVelocity * (Math.PI / 180);
    //

    if (intersect.length > 0) {
      var interPoint = intersect[0].point.clone();

      line.geometry.vertices[0] = clone.clone();
      line.geometry.vertices[1] = interPoint.clone();

      line.geometry.verticesNeedUpdate = true;

      redDebug.position = interPoint.clone();

      if (Math.abs(intersect[0].distance))
        greenBox.position.y += 12.5 - intersect[0].distance;
    }

    redPoint = redBox.position.clone();
    greenBox.localToWorld(redPoint);

    if (intersectB.length > 0) {
      var interPoint = intersectB[0].point.clone();

      line.geometry.vertices[0] = cloneB.clone();
      line.geometry.vertices[1] = interPoint.clone();

      line.geometry.verticesNeedUpdate = true;

      redDebug.position = interPoint.clone();

      if (Math.abs(intersectB[0].distance))
        greenBox.position.y += 12.5 - intersectB[0].distance;

    }
  }
}

Main.init('container');

var yellow = new THREE.MeshBasicMaterial({ color: 0xFFFF00, wireframe: true });
var yellowBox = new THREE.Mesh(new THREE.BoxGeometry(25, 10, 100), yellow);
var yellowBoxB = new THREE.Mesh(new THREE.BoxGeometry(25, 10, 100), yellow);

// var yellowBoxA = new THREE.Mesh(new THREE.BoxGeometry(25, 25, 25), yellow);
// var yellowBoxB = new THREE.Mesh(new THREE.BoxGeometry(25, 15, 50), yellow);

yellowBox.rotation.x = Math.PI / 8;

// yellowBox.add(yellowBoxA);
// yellowBox.add(yellowBoxB);

yellowBox.position.y -= 100;
yellowBox.position.z += -50;

yellowBoxB.position.y -= 100;
yellowBoxB.position.z += 50;

Main.scene.add(yellowBox);
Main.scene.add(yellowBoxB);

var red = new THREE.MeshBasicMaterial({ color: 0xFF0000, wireframe: true });
var green = new THREE.MeshBasicMaterial({ color: 0x00FF00, wireframe: true })
var blue = new THREE.MeshBasicMaterial({ color: 0x0000FF, wireframe: true });

var redBox = new THREE.Mesh(new THREE.CylinderGeometry(12.5, 12.5, 10, 16), red);
var greenBox = new THREE.Mesh(new THREE.BoxGeometry(25, 25, 25), green);
var blueBox = new THREE.Mesh(new THREE.CylinderGeometry(12.5, 12.5, 10, 16), blue);

var redDebug = new THREE.Mesh(new THREE.BoxGeometry(5, 5, 5), red);
Main.scene.add(redDebug);

greenBox.rotation.x = Math.PI / 4;

greenBox.add(redBox);
greenBox.add(blueBox);

redBox.position.z += -50;
redBox.rotation.z += Math.PI / 2;
blueBox.position.z += 50;
blueBox.rotation.z += Math.PI / 2;

greenBox.position.y += 10;

Main.scene.add(greenBox);

var material = new THREE.LineBasicMaterial({ color: 0xFFFFFF });

var geometry = new THREE.Geometry();
geometry.vertices.push(new THREE.Vector3(-10, 0, 0));
geometry.vertices.push(new THREE.Vector3(0, 10, 0));

var line = new THREE.Line(geometry, material);

Main.scene.add(line);

Main.animate();
</script>
</script>
